{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Indian Legal Dataset Preparation's Documentation","text":"<p>Welcome to the documentation for the Indian Legal Dataset Preparation Repo. This repository consists of various scripts to process Indian legal case data. The scripts have been written to work with the HTML structure of documents as provided by Indian Kanoon but should work with minor tweaking for other formats. The functionalities provided are:</p> <ul> <li>Basic text cleanup.</li> <li>Extraction of textual portions of case documents.</li> <li>Crude identification and removal preamble sections of documents.</li> <li>Extraction of statutes: (Areas, Acts, Chapters and Sections)</li> <li>Identification of rhetorical roles of sentences (utilised a modified version   of Semantic Segmentation.</li> <li>Extraction of names of advocates (as petitioners or respondents).</li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>adv_info<ul> <li>get_advocates</li> <li>get_area_act_chapter_section_info</li> <li>utils</li> </ul> </li> <li>area_act_chapter_section_info<ul> <li>get_area_act_chapter_section_info</li> <li>utils</li> </ul> </li> <li>check<ul> <li>check_adv_leakage</li> <li>check_section_leakage</li> <li>utils</li> </ul> </li> <li>fold_creation<ul> <li>create_folds</li> <li>create_per_target_balanced_splits</li> <li>create_splits</li> <li>create_splits_multilabel</li> <li>get_target_splits</li> <li>utils</li> </ul> </li> <li>preprocess<ul> <li>align_statute_spans</li> <li>clean</li> <li>combine</li> <li>extract_statutes</li> <li>get_roles_sentences</li> <li>get_sentences</li> <li>mask_advs</li> <li>mask_ent</li> <li>mask_statutes</li> <li>process</li> <li>segment</li> <li>utils</li> </ul> </li> <li>selection<ul> <li>notebooks<ul> <li>check_skmultilearn</li> </ul> </li> <li>select_advocates</li> <li>select_cases_from_groups</li> <li>select_databank_cases</li> <li>utils</li> </ul> </li> <li>targets<ul> <li>get_balanced_targets</li> <li>get_per_charge_win_ratios</li> <li>get_silver_targets</li> <li>get_targets</li> <li>get_winning_advs</li> <li>utils</li> </ul> </li> </ul>"},{"location":"reference/adv_info/get_advocates/","title":"get_advocates","text":"<p>Finds names of advocates in a given set of files and creates an advocate-case mapping.</p>"},{"location":"reference/adv_info/get_area_act_chapter_section_info/","title":"get_area_act_chapter_section_info","text":"<p>Find section, chapter and act information of advocates.</p>"},{"location":"reference/adv_info/get_area_act_chapter_section_info/#src.adv_info.get_area_act_chapter_section_info.get_area_act_chapter_section_info","title":"<code>get_area_act_chapter_section_info(secs, area_info, chapter_info)</code>","text":"<p>Return act, chapter and section frequency dictionary from list of sections.</p>"},{"location":"reference/adv_info/get_area_act_chapter_section_info/#src.adv_info.get_area_act_chapter_section_info.get_area_act_chapter_section_info--parameters","title":"Parameters","text":"list <p>List of sections cited</p> dict <p>Information of areas for all acts to get area information</p> dict <p>Information of chapters for all sections to get chapter information</p>"},{"location":"reference/adv_info/get_area_act_chapter_section_info/#src.adv_info.get_area_act_chapter_section_info.get_area_act_chapter_section_info--returns","title":"Returns","text":"<p>dict</p> Source code in <code>src/adv_info/get_area_act_chapter_section_info.py</code> <pre><code>def get_area_act_chapter_section_info(secs: list, area_info: dict,\n                                      chapter_info: dict) -&gt; dict:\n\"\"\"Return act, chapter and section frequency dictionary\n    from list of sections.\n\n    Parameters\n    ----------\n    secs : list\n        List of sections cited\n    area_info: dict\n        Information of areas for all acts to get area information\n    chapter_info: dict\n        Information of chapters for all sections to get chapter information\n\n    Returns\n    -------\n    dict\n\n    \"\"\"\n\n    acts = list(map(lambda x: x.split(\"_\")[0], secs))\n    acts = dict(Counter(acts))\n    acts = order(acts)\n    areas = list(filter(None, map(lambda x: area_info.get(x, \"\"),\n                                  acts.keys())))\n    areas = list(chain.from_iterable(areas))\n    areas = dict(Counter(list(areas)))\n    areas = order(areas)\n    sections = dict(Counter(secs))\n    sections = order(sections)\n    chapters = list(filter(None, map(lambda x: chapter_info.get(x, \"\"), secs)))\n    chapters = dict(Counter(chapters))\n    chapters = order(chapters)\n\n    statute = {\n            \"areas\": areas,\n            \"acts\": acts,\n            \"chapters\": chapters,\n            \"sections\": sections,\n            }\n\n    return statute\n</code></pre>"},{"location":"reference/adv_info/utils/","title":"utils","text":"<p>Common utilities.</p>"},{"location":"reference/adv_info/utils/#src.adv_info.utils.clean_names","title":"<code>clean_names(adv_list, check=None)</code>","text":"<p>Takes a list of advocate names, a dictionary of advocates with their assigned cases and a case text and adds the case to the appropriate advocate with the right prefix for petitioner or respondent</p> Source code in <code>src/adv_info/utils.py</code> <pre><code>def clean_names(adv_list, check=None):\n\"\"\"Takes a list of advocate names, a dictionary of advocates with their\n    assigned cases and a case text and adds the case to the appropriate\n    advocate with the right prefix for petitioner or respondent\n    \"\"\"\n\n    salutations = ['Mr', 'Ms', 'Mrs', 'Dr', 'Mr.', 'Mrs.', 'Ms.', 'Dr.']\n    except_tokens = [\"For\", \"CORAM\", \"Hon'ble\", \"Advocate\", \"Advocates\"]\n    cleaned_advs = []\n\n    for adv in adv_list:\n        adv = re.split(r',|\\.|\\s+', adv)\n\n        adv = list(filter(None, adv))\n\n        # Using replace instead of strip due to abbreviated names with\n        adv = [token for token in adv\n               if token[0].isupper() and token not in salutations\n               and token not in except_tokens]\n\n        if(len(adv) &lt;= 1):\n            continue\n        cleaned_advs.append(\"\".join(adv))\n\n    if check is not None:\n        return list(set([adv for adv in cleaned_advs if adv not in check]))\n\n    return list(set(cleaned_advs))\n</code></pre>"},{"location":"reference/adv_info/utils/#src.adv_info.utils.order","title":"<code>order(dict_obj)</code>","text":"<p>Order dictionary in decreasing order of values</p>"},{"location":"reference/adv_info/utils/#src.adv_info.utils.order--parameters","title":"Parameters","text":"dict <p>Dictionary to be sorted.</p>"},{"location":"reference/adv_info/utils/#src.adv_info.utils.order--returns","title":"Returns","text":"<p>dict</p> Source code in <code>src/adv_info/utils.py</code> <pre><code>def order(dict_obj: dict) -&gt; dict:\n\"\"\"Order dictionary in decreasing order of values\n\n    Parameters\n    ----------\n    dict_obj : dict\n        Dictionary to be sorted.\n\n    Returns\n    -------\n    dict\n\n    \"\"\"\n\n    ordered_dict = {\n            k: v for k, v in sorted(dict_obj.items(),\n                                    key=lambda x: x[1],\n                                    reverse=True)}\n    return ordered_dict\n</code></pre>"},{"location":"reference/adv_info/utils/#src.adv_info.utils.set_logger","title":"<code>set_logger(log_path)</code>","text":"<p>Set logger to log information to the terminal and the specified path.</p>"},{"location":"reference/adv_info/utils/#src.adv_info.utils.set_logger--parameters","title":"Parameters","text":"str <p>Path to log run-stats to.</p> Source code in <code>src/adv_info/utils.py</code> <pre><code>def set_logger(log_path):\n\"\"\"Set logger to log information to the terminal and the specified path.\n\n    Parameters\n    ----------\n    log_path : str\n        Path to log run-stats to.\n    \"\"\"\n    timestamp = time.strftime(\"%Y-%m-%d-%H-%m-%S\")\n\n    log_path = log_path + \"_\" + timestamp + \".log\"\n\n    logger = logging.getLogger()\n    logger.setLevel(logging.INFO)\n\n    if not logger.handlers:\n        # FileHandler to log to a file\n        file_handler = logging.FileHandler(log_path)\n        file_handler.setFormatter(logging.Formatter(\n            \"%(asctime)s : [%(levelname)s] %(message)s\",\n            \"%Y-%m-%d %H:%M:%S\"))\n        logger.addHandler(file_handler)\n\n        # StreamHandler to log to terminal\n        stream_handler = logging.StreamHandler()\n        stream_handler.setFormatter(logging.Formatter(\n            \"%(asctime)s : [%(levelname)s] %(message)s\",\n            \"%Y-%m-%d %H:%M:%S\"))\n        logger.addHandler(stream_handler)\n</code></pre>"},{"location":"reference/adv_info/utils/#src.adv_info.utils.time_logger","title":"<code>time_logger(original_func)</code>","text":"<p>Time logging for method.</p> Source code in <code>src/adv_info/utils.py</code> <pre><code>def time_logger(original_func):\n\"\"\"Time logging for method.\"\"\"\n\n    @wraps(original_func)\n    def wrapper(*args, **kwargs):\n        start = time.time()\n        result = original_func(*args, **kwargs)\n        elapsed = time.time() - start\n        logging.info(\n            f\"Method {original_func.__name__} ran for {elapsed:.3f} sec(s)\")\n        return result\n    return wrapper\n</code></pre>"},{"location":"reference/area_act_chapter_section_info/","title":"README","text":"<ul> <li><code>get_area_act_chapter_section_info.py</code>: Using statute information extracted    from documents, creates a comprehensive dictionary with the area, act,    chapter and section information of each document.</li> <li><code>run_get_area_act_chapter_section_info.sh</code>: Helper script to run    <code>get_area_act_chapter_section_info.py</code> by passing command-line arguments.</li> </ul>"},{"location":"reference/area_act_chapter_section_info/get_area_act_chapter_section_info/","title":"get_area_act_chapter_section_info","text":"<p>Find section, chapter, act and area information of cases.</p>"},{"location":"reference/area_act_chapter_section_info/get_area_act_chapter_section_info/#src.area_act_chapter_section_info.get_area_act_chapter_section_info.get_area_act_chapter_section_info","title":"<code>get_area_act_chapter_section_info(secs, area_info, chapter_info)</code>","text":"<p>Return act, chapter and section frequency dictionary from list of sections.</p>"},{"location":"reference/area_act_chapter_section_info/get_area_act_chapter_section_info/#src.area_act_chapter_section_info.get_area_act_chapter_section_info.get_area_act_chapter_section_info--parameters","title":"Parameters","text":"list <p>List of sections cited</p> dict <p>Information of areas for all acts to get area information</p> dict <p>Information of chapters for all sections to get chapter information</p>"},{"location":"reference/area_act_chapter_section_info/get_area_act_chapter_section_info/#src.area_act_chapter_section_info.get_area_act_chapter_section_info.get_area_act_chapter_section_info--returns","title":"Returns","text":"<p>dict</p> Source code in <code>src/area_act_chapter_section_info/get_area_act_chapter_section_info.py</code> <pre><code>def get_area_act_chapter_section_info(\n    secs: list, area_info: dict, chapter_info: dict\n) -&gt; dict:\n\"\"\"Return act, chapter and section frequency dictionary\n    from list of sections.\n\n    Parameters\n    ----------\n    secs : list\n        List of sections cited\n    area_info: dict\n        Information of areas for all acts to get area information\n    chapter_info: dict\n        Information of chapters for all sections to get chapter information\n\n    Returns\n    -------\n    dict\n\n    \"\"\"\n\n    acts = list(map(lambda x: x.split(\"_\")[0], secs))\n    acts = dict(Counter(acts))\n    acts = order(acts)\n    areas = list(\n        filter(None, map(lambda x: area_info.get(x, \"\"), acts.keys()))\n    )\n    areas = list(chain.from_iterable(areas))\n    areas = dict(Counter(list(areas)))\n    areas = order(areas)\n    sections = dict(Counter(secs))\n    sections = order(sections)\n    chapters = list(filter(None, map(lambda x: chapter_info.get(x, \"\"), secs)))\n    chapters = dict(Counter(chapters))\n    chapters = order(chapters)\n\n    statute = {\n        \"areas\": areas,\n        \"acts\": acts,\n        \"chapters\": chapters,\n        \"sections\": sections,\n    }\n\n    return statute\n</code></pre>"},{"location":"reference/area_act_chapter_section_info/utils/","title":"utils","text":"<p>Common utilities.</p>"},{"location":"reference/area_act_chapter_section_info/utils/#src.area_act_chapter_section_info.utils.clean_names","title":"<code>clean_names(adv_list, check=None)</code>","text":"<p>Takes a list of advocate names, a dictionary of advocates with their assigned cases and a case text and adds the case to the appropriate advocate with the right prefix for petitioner or respondent</p> Source code in <code>src/area_act_chapter_section_info/utils.py</code> <pre><code>def clean_names(adv_list, check=None):\n\"\"\"Takes a list of advocate names, a dictionary of advocates with their\n    assigned cases and a case text and adds the case to the appropriate\n    advocate with the right prefix for petitioner or respondent\n    \"\"\"\n\n    salutations = ['Mr', 'Ms', 'Mrs', 'Dr', 'Mr.', 'Mrs.', 'Ms.', 'Dr.']\n    except_tokens = [\"For\", \"CORAM\", \"Hon'ble\", \"Advocate\", \"Advocates\"]\n    cleaned_advs = []\n\n    for adv in adv_list:\n        adv = re.split(r',|\\.|\\s+', adv)\n\n        adv = list(filter(None, adv))\n\n        # Using replace instead of strip due to abbreviated names with\n        adv = [token for token in adv\n               if token[0].isupper() and token not in salutations\n               and token not in except_tokens]\n\n        if(len(adv) &lt;= 1):\n            continue\n        cleaned_advs.append(\"\".join(adv))\n\n    if check is not None:\n        return list(set([adv for adv in cleaned_advs if adv not in check]))\n\n    return list(set(cleaned_advs))\n</code></pre>"},{"location":"reference/area_act_chapter_section_info/utils/#src.area_act_chapter_section_info.utils.order","title":"<code>order(dict_obj)</code>","text":"<p>Order dictionary in decreasing order of values</p>"},{"location":"reference/area_act_chapter_section_info/utils/#src.area_act_chapter_section_info.utils.order--parameters","title":"Parameters","text":"dict <p>Dictionary to be sorted.</p>"},{"location":"reference/area_act_chapter_section_info/utils/#src.area_act_chapter_section_info.utils.order--returns","title":"Returns","text":"<p>dict</p> Source code in <code>src/area_act_chapter_section_info/utils.py</code> <pre><code>def order(dict_obj: dict) -&gt; dict:\n\"\"\"Order dictionary in decreasing order of values\n\n    Parameters\n    ----------\n    dict_obj : dict\n        Dictionary to be sorted.\n\n    Returns\n    -------\n    dict\n\n    \"\"\"\n\n    ordered_dict = {\n            k: v for k, v in sorted(dict_obj.items(),\n                                    key=lambda x: x[1],\n                                    reverse=True)}\n    return ordered_dict\n</code></pre>"},{"location":"reference/area_act_chapter_section_info/utils/#src.area_act_chapter_section_info.utils.set_logger","title":"<code>set_logger(log_path)</code>","text":"<p>Set logger to log information to the terminal and the specified path.</p>"},{"location":"reference/area_act_chapter_section_info/utils/#src.area_act_chapter_section_info.utils.set_logger--parameters","title":"Parameters","text":"str <p>Path to log run-stats to.</p> Source code in <code>src/area_act_chapter_section_info/utils.py</code> <pre><code>def set_logger(log_path):\n\"\"\"Set logger to log information to the terminal and the specified path.\n\n    Parameters\n    ----------\n    log_path : str\n        Path to log run-stats to.\n    \"\"\"\n    timestamp = time.strftime(\"%Y-%m-%d-%H-%m-%S\")\n\n    log_path = log_path + \"_\" + timestamp + \".log\"\n\n    logger = logging.getLogger()\n    logger.setLevel(logging.INFO)\n\n    if not logger.handlers:\n        # FileHandler to log to a file\n        file_handler = logging.FileHandler(log_path)\n        file_handler.setFormatter(logging.Formatter(\n            \"%(asctime)s : [%(levelname)s] %(message)s\",\n            \"%Y-%m-%d %H:%M:%S\"))\n        logger.addHandler(file_handler)\n\n        # StreamHandler to log to terminal\n        stream_handler = logging.StreamHandler()\n        stream_handler.setFormatter(logging.Formatter(\n            \"%(asctime)s : [%(levelname)s] %(message)s\",\n            \"%Y-%m-%d %H:%M:%S\"))\n        logger.addHandler(stream_handler)\n</code></pre>"},{"location":"reference/area_act_chapter_section_info/utils/#src.area_act_chapter_section_info.utils.time_logger","title":"<code>time_logger(original_func)</code>","text":"<p>Time logging for method.</p> Source code in <code>src/area_act_chapter_section_info/utils.py</code> <pre><code>def time_logger(original_func):\n\"\"\"Time logging for method.\"\"\"\n\n    @wraps(original_func)\n    def wrapper(*args, **kwargs):\n        start = time.time()\n        result = original_func(*args, **kwargs)\n        elapsed = time.time() - start\n        logging.info(\n            f\"Method {original_func.__name__} ran for {elapsed:.3f} sec(s)\")\n        return result\n    return wrapper\n</code></pre>"},{"location":"reference/check/check_adv_leakage/","title":"check_adv_leakage","text":"<p>Check leakage of advocate information in texts</p>"},{"location":"reference/check/check_section_leakage/","title":"check_section_leakage","text":"<p>Check for section leakage after masking</p>"},{"location":"reference/check/utils/","title":"utils","text":"<p>Utilities for pre-processing.</p>"},{"location":"reference/check/utils/#src.check.utils.DotDict","title":"<code>DotDict</code>","text":"<p>         Bases: <code>dict</code></p> <p>dot.notation access to dictionary attributes</p> Source code in <code>src/check/utils.py</code> <pre><code>class DotDict(dict):\n\"\"\"dot.notation access to dictionary attributes\"\"\"\n    def __getattr__(*args):\n        val = dict.get(*args)\n        return DotDict(val) if type(val) is dict else val\n\n    __setattr__ = dict.__setitem__\n    __delattr__ = dict.__delitem__\n</code></pre>"},{"location":"reference/check/utils/#src.check.utils.get_text","title":"<code>get_text(path, log_path=None)</code>","text":"<p>Load html data and return text of the of <p> divs of the data.</p> Source code in <code>src/check/utils.py</code> <pre><code>def get_text(path: str, log_path: str = None) -&gt; str:\n\"\"\"Load html data and return text of the of &lt;p&gt; divs of the data.\"\"\"\n\n    if log_path is not None:\n        set_logger(log_path)\n    logging.info(f\"Reading data from {path}\")\n    with open(path, 'r') as f:\n        raw = f.read()\n    soup = bs(raw, 'html.parser')\n    text = \" \". join([div.text for div in soup.find_all('p')])\n    return text\n</code></pre>"},{"location":"reference/check/utils/#src.check.utils.order","title":"<code>order(dict_obj)</code>","text":"<p>Order dictionary in decreasing order of values</p>"},{"location":"reference/check/utils/#src.check.utils.order--parameters","title":"Parameters","text":"dict <p>Dictionary to be sorted.</p>"},{"location":"reference/check/utils/#src.check.utils.order--returns","title":"Returns","text":"<p>dict</p> Source code in <code>src/check/utils.py</code> <pre><code>def order(dict_obj: dict) -&gt; dict:\n\"\"\"Order dictionary in decreasing order of values\n\n    Parameters\n    ----------\n    dict_obj : dict\n        Dictionary to be sorted.\n\n    Returns\n    -------\n    dict\n\n    \"\"\"\n\n    ordered_dict = {\n            k: v for k, v in sorted(dict_obj.items(),\n                                    key=lambda x: x[1],\n                                    reverse=True)}\n    return ordered_dict\n</code></pre>"},{"location":"reference/check/utils/#src.check.utils.save_format","title":"<code>save_format(path, flname, data)</code>","text":"<p>Saves data to the given path depending on the data type.</p> Source code in <code>src/check/utils.py</code> <pre><code>def save_format(path, flname, data):\n\"\"\"Saves data to the given path depending on the data type.\"\"\"\n\n    if (type(data) == str):\n        with open(os.path.join(path, f\"{flname}.txt\"), 'w') as f:\n            f.write(data)\n\n    if (type(data) == dict):\n        with open(os.path.join(path, f\"{flname}.json\"), 'w') as f:\n            json.dump(data, f, indent=4)\n</code></pre>"},{"location":"reference/check/utils/#src.check.utils.set_logger","title":"<code>set_logger(log_path)</code>","text":"<p>Set logger to log information to the terminal and the specified path.</p>"},{"location":"reference/check/utils/#src.check.utils.set_logger--parameters","title":"Parameters","text":"str <p>Path to log run-stats to.</p> Source code in <code>src/check/utils.py</code> <pre><code>def set_logger(log_path):\n\"\"\"Set logger to log information to the terminal and the specified path.\n\n    Parameters\n    ----------\n    log_path : str\n        Path to log run-stats to.\n    \"\"\"\n\n    timestamp = strftime(\"%Y-%m-%d-%H-%M-%S\")\n    log_path = log_path + \"_\" + timestamp + \".log\"\n\n    logger = logging.getLogger()\n    logger.setLevel(logging.INFO)\n\n    if not logger.handlers:\n        # FileHandler to log to a file\n        file_handler = logging.FileHandler(log_path)\n        file_handler.setFormatter(logging.Formatter(\n            \"%(asctime)s : [%(levelname)s] %(message)s\",\n            \"%Y-%m-%d %H:%M:%S\"))\n        logger.addHandler(file_handler)\n\n        # StreamHandler to log to terminal\n        stream_handler = logging.StreamHandler()\n        stream_handler.setFormatter(logging.Formatter(\n            \"%(asctime)s : [%(levelname)s] %(message)s\",\n            \"%Y-%m-%d %H:%M:%S\"))\n        logger.addHandler(stream_handler)\n</code></pre>"},{"location":"reference/fold_creation/","title":"README","text":"<p>Overview of scripts.</p> <ul> <li><code>create_per_target_balanced_splits.py</code>: Creates a train-test-validation split   on a set of datapoints given their targets. For each target, splits the   datapoints of the target into three splits by the given proportion and ensures   a minimal (user-defined) value of representation of each target in the   training and testing splits. DOES NOT ensure the same for the validation split   due to insufficient representation for a large number of targets (for the   advocate recommendation use-case).</li> <li><code>run_create_per_target_balanced_splits.sh</code>: Helper script for executing    <code>create_per_target_balanced_splits.py</code> by passing command-line arguments.</li> </ul>"},{"location":"reference/fold_creation/#todo-update-other-scripts","title":"TODO: Update other scripts","text":""},{"location":"reference/fold_creation/create_folds/","title":"create_folds","text":"<p>Create train-test folds for given data</p>"},{"location":"reference/fold_creation/create_per_target_balanced_splits/","title":"create_per_target_balanced_splits","text":""},{"location":"reference/fold_creation/create_per_target_balanced_splits/#src.fold_creation.create_per_target_balanced_splits.checkandremove","title":"<code>checkandremove(datapoints, segment, data_targets, min_count)</code>","text":"<p>Check and remove potential leakage points</p>"},{"location":"reference/fold_creation/create_per_target_balanced_splits/#src.fold_creation.create_per_target_balanced_splits.checkandremove--parameters","title":"Parameters","text":"list[str] <p>Points to check for leakage</p> set[str] <p>Segment against which to check leakage</p> dict[str, list[str]] <p>Targets for each datapoint (used for selecting points to remove/add)</p> int <p>Minimum count to ensure for datapoints</p>"},{"location":"reference/fold_creation/create_per_target_balanced_splits/#src.fold_creation.create_per_target_balanced_splits.checkandremove--returns","title":"Returns","text":"<p>(list[str], set[str])     Updated datapoints and segment</p> Source code in <code>src/fold_creation/create_per_target_balanced_splits.py</code> <pre><code>def checkandremove(\n    datapoints: list[str],\n    segment: set[str],\n    data_targets: dict[str, list[str]],\n    min_count: int,\n) -&gt; (list[str], set[str]):\n\"\"\"Check and remove potential leakage points\n\n    Parameters\n    ----------\n    datapoints : list[str]\n        Points to check for leakage\n    segment : set[str]\n        Segment against which to check leakage\n    data_targets : dict[str, list[str]]\n        Targets for each datapoint (used for selecting points to remove/add)\n    min_count : int\n        Minimum count to ensure for datapoints\n\n    Returns\n    -------\n    (list[str], set[str])\n        Updated datapoints and segment\n    \"\"\"\n    datap_seg_overlap = datapoints.intersection(segment)\n    if len(datap_seg_overlap) != 0:\n        datapoints = datapoints.difference(datap_seg_overlap)\n        if len(datapoints) &lt; min_count:\n            ordered = sorted(\n                datap_seg_overlap, key=lambda x: len(data_targets[x])\n            )\n            to_add = ordered[: min_count - len(datapoints)]\n            datapoints.update(to_add)\n            segment = segment.difference(to_add)\n    return datapoints, segment\n</code></pre>"},{"location":"reference/fold_creation/create_per_target_balanced_splits/#src.fold_creation.create_per_target_balanced_splits.save","title":"<code>save(path, obj)</code>","text":"<p>Utility to save generated information</p>"},{"location":"reference/fold_creation/create_per_target_balanced_splits/#src.fold_creation.create_per_target_balanced_splits.save--parameters","title":"Parameters","text":"list <p>Path to create from list to save data to</p> object <p>Object to save</p> Source code in <code>src/fold_creation/create_per_target_balanced_splits.py</code> <pre><code>def save(path: list, obj: object) -&gt; None:\n\"\"\"Utility to save generated information\n\n    Parameters\n    ----------\n    path : list\n        Path to create from list to save data to\n    obj : object\n        Object to save\n    \"\"\"\n    savepath = os.path.join(*path)\n    if type(obj) in [list, set]:\n        with open(savepath, \"w\") as f:\n            for line in obj:\n                print(line, file=f, end=\"\\n\")\n    elif type(obj) == dict:\n        with open(savepath, \"w\") as f:\n            json.dump(obj, f, indent=4)\n    else:\n        logging.error(f\"Unrecognised format {type(obj)} for saving&gt;\")\n</code></pre>"},{"location":"reference/fold_creation/create_per_target_balanced_splits/#src.fold_creation.create_per_target_balanced_splits.update","title":"<code>update(segment, target_seg_data)</code>","text":"<p>Update target segment dictionary</p>"},{"location":"reference/fold_creation/create_per_target_balanced_splits/#src.fold_creation.create_per_target_balanced_splits.update--parameters","title":"Parameters","text":"set[str] <p>Updated segment to update target dictionary</p> dict[str, list[str]] <p>Dictionary target segment to update</p>"},{"location":"reference/fold_creation/create_per_target_balanced_splits/#src.fold_creation.create_per_target_balanced_splits.update--returns","title":"Returns","text":"<p>dict[str, list[str]]     Updated dictionary target segment</p> Source code in <code>src/fold_creation/create_per_target_balanced_splits.py</code> <pre><code>def update(\n    segment: set[str], target_seg_data: dict[str, list[str]]\n) -&gt; dict[str, list[str]]:\n\"\"\"Update target segment dictionary\n\n    Parameters\n    ----------\n    segment : set[str]\n       Updated segment to update target dictionary\n    target_seg_data : dict[str, list[str]]\n        Dictionary target segment to update\n\n    Returns\n    -------\n    dict[str, list[str]]\n        Updated dictionary target segment\n    \"\"\"\n    for k, v in target_seg_data.items():\n        target_seg_data[k] = list(v.intersection(segment))\n    return target_seg_data\n</code></pre>"},{"location":"reference/fold_creation/create_splits/","title":"create_splits","text":"<p>Create train, test, validation splits along with cross-validation variants.</p>"},{"location":"reference/fold_creation/create_splits_multilabel/","title":"create_splits_multilabel","text":"<p>Create train, test, validation splits along with cross-validation variants.</p>"},{"location":"reference/fold_creation/get_target_splits/","title":"get_target_splits","text":"<p>Get split of targets based on dataset train-test split and per-target datapoints</p>"},{"location":"reference/fold_creation/utils/","title":"utils","text":"<p>Utilities for pre-processing.</p>"},{"location":"reference/fold_creation/utils/#src.fold_creation.utils.DotDict","title":"<code>DotDict</code>","text":"<p>         Bases: <code>dict</code></p> <p>dot.notation access to dictionary attributes</p> Source code in <code>src/fold_creation/utils.py</code> <pre><code>class DotDict(dict):\n\"\"\"dot.notation access to dictionary attributes\"\"\"\n    def __getattr__(*args):\n        val = dict.get(*args)\n        return DotDict(val) if type(val) is dict else val\n\n    __setattr__ = dict.__setitem__\n    __delattr__ = dict.__delitem__\n</code></pre>"},{"location":"reference/fold_creation/utils/#src.fold_creation.utils.get_text","title":"<code>get_text(path, log_path=None)</code>","text":"<p>Load html data and return text of the data.</p> Source code in <code>src/fold_creation/utils.py</code> <pre><code>def get_text(path: str, log_path: str = None) -&gt; str:\n\"\"\"Load html data and return text of the data.\"\"\"\n\n    if log_path is not None:\n        set_logger(log_path)\n    logging.info(f\"Reading data from {path}\")\n    with open(path, 'r') as f:\n        raw = f.read()\n    soup = bs(raw, 'html.parser')\n    text = soup.get_text()\n    return text\n</code></pre>"},{"location":"reference/fold_creation/utils/#src.fold_creation.utils.order","title":"<code>order(dict_obj)</code>","text":"<p>Order dictionary in decreasing order of values</p>"},{"location":"reference/fold_creation/utils/#src.fold_creation.utils.order--parameters","title":"Parameters","text":"dict <p>Dictionary to be sorted.</p>"},{"location":"reference/fold_creation/utils/#src.fold_creation.utils.order--returns","title":"Returns","text":"<p>dict</p> Source code in <code>src/fold_creation/utils.py</code> <pre><code>def order(dict_obj: dict) -&gt; dict:\n\"\"\"Order dictionary in decreasing order of values\n\n    Parameters\n    ----------\n    dict_obj : dict\n        Dictionary to be sorted.\n\n    Returns\n    -------\n    dict\n\n    \"\"\"\n\n    ordered_dict = {\n            k: v for k, v in sorted(dict_obj.items(),\n                                    key=lambda x: x[1],\n                                    reverse=True)}\n    return ordered_dict\n</code></pre>"},{"location":"reference/fold_creation/utils/#src.fold_creation.utils.save_format","title":"<code>save_format(path, flname, data)</code>","text":"<p>Saves data to the given path depending on the data type.</p> Source code in <code>src/fold_creation/utils.py</code> <pre><code>def save_format(path, flname, data):\n\"\"\"Saves data to the given path depending on the data type.\"\"\"\n\n    if (type(data) == str):\n        with open(os.path.join(path, f\"{flname}.txt\"), 'w') as f:\n            f.write(data)\n\n    if (type(data) == dict):\n        with open(os.path.join(path, f\"{flname}.json\"), 'w') as f:\n            json.dump(data, f, indent=4)\n</code></pre>"},{"location":"reference/fold_creation/utils/#src.fold_creation.utils.set_logger","title":"<code>set_logger(log_path)</code>","text":"<p>Set logger to log information to the terminal and the specified path.</p>"},{"location":"reference/fold_creation/utils/#src.fold_creation.utils.set_logger--parameters","title":"Parameters","text":"str <p>Path to log run-stats to.</p> Source code in <code>src/fold_creation/utils.py</code> <pre><code>def set_logger(log_path):\n\"\"\"Set logger to log information to the terminal and the specified path.\n\n    Parameters\n    ----------\n    log_path : str\n        Path to log run-stats to.\n    \"\"\"\n\n    timestamp = strftime(\"%Y-%m-%d-%H-%M-%S\")\n    log_path = log_path + \"_\" + timestamp + \".log\"\n\n    logger = logging.getLogger()\n    logger.setLevel(logging.INFO)\n\n    if not logger.handlers:\n        # FileHandler to log to a file\n        file_handler = logging.FileHandler(log_path)\n        file_handler.setFormatter(logging.Formatter(\n            \"%(asctime)s : [%(levelname)s] %(message)s\",\n            \"%Y-%m-%d %H:%M:%S\"))\n        logger.addHandler(file_handler)\n\n        # StreamHandler to log to terminal\n        stream_handler = logging.StreamHandler()\n        stream_handler.setFormatter(logging.Formatter(\n            \"%(asctime)s : [%(levelname)s] %(message)s\",\n            \"%Y-%m-%d %H:%M:%S\"))\n        logger.addHandler(stream_handler)\n</code></pre>"},{"location":"reference/preprocess/","title":"Preprocessing documents","text":"<ul> <li><code>clean.py</code>: Takes html-format documents as input and cleans up text portions.   Saves cleaned documents as text.</li> <li><code>mask.py</code>: Takes text documents generated by <code>clean.py</code> and masks certain   tokens and information. Saves masked documents as text.</li> <li><code>segment.py</code>: Takes texts documents generated by <code>mask.py</code> OR <code>clean.py</code> and   segments into sentencecs. Saves as dictionaries where each key is a line   number and the information is the text and the span of the line.</li> <li><code>extract_statutes.py</code>: Takes dictionary information generated by <code>segment.py</code>   and extracts statutes for each sentence. Saves as dictionaries as generated by   <code>segment.py</code> with an added section and act information for each line.</li> <li><code>get_sentences.py</code>: Gets the per-sentence text for each document generated by   <code>segment.py</code> OR <code>extract_statutes.py</code>. Saves the lines as text. Used for   rhetorical role extraction.</li> <li><code>combine.py</code>: Combines the rhetorical role information of each line into the   dictionary data generated by <code>segment.py</code> or <code>extract_statutes.py</code>.</li> <li><code>utils.py</code>: General utilities required by all other scripts for loading,   saving and logging.</li> <li>act_titles.py: List of acts used for extraction of statutes.</li> <li><code>section_titles.py</code>: List of sections/statutes used for verification of   extracted statutes.</li> <li><code>section_titles.json</code>: Converts the list 'section_titles.txt' into a dictionary   for faster access.</li> <li><code>process.py</code>: INEFFICIENT Applies the pipeline of all processing. VERY   SLOW. DO NOT USE.</li> </ul>"},{"location":"reference/preprocess/align_statute_spans/","title":"align_statute_spans","text":"<p>Mask sections in cases</p>"},{"location":"reference/preprocess/align_statute_spans/#src.preprocess.align_statute_spans.get_closest","title":"<code>get_closest(tuple_a, tuple_list)</code>","text":"<p>Return closest tuple based on first coordinate criteria</p> Source code in <code>src/preprocess/align_statute_spans.py</code> <pre><code>def get_closest(tuple_a: tuple, tuple_list: list) -&gt; tuple:\n\"\"\"Return closest tuple based on first coordinate criteria\"\"\"\n    least = 0\n    dist = tuple_a[0] - tuple_list[0][0]\n    for i in range(len(tuple_list)):\n        if not tuple_list[i][0] &lt;= tuple_a[0]:\n            continue\n        n_dist = tuple_a[0] - tuple_list[i][0]\n        if n_dist &lt;= dist:\n            dist = n_dist\n            least = i\n    return tuple_list[least]\n</code></pre>"},{"location":"reference/preprocess/align_statute_spans/#src.preprocess.align_statute_spans.get_new_spans","title":"<code>get_new_spans(data, sections)</code>","text":"<p>Realign spans of sections after Masking</p>"},{"location":"reference/preprocess/align_statute_spans/#src.preprocess.align_statute_spans.get_new_spans--parameters","title":"Parameters","text":"str <p>Text information</p> dict <p>Dictionary with sections and their spans</p> Source code in <code>src/preprocess/align_statute_spans.py</code> <pre><code>def get_new_spans(data: str, sections: dict) -&gt; dict:\n\"\"\"Realign spans of sections after Masking\n\n    Parameters\n    ----------\n    data: str\n        Text information\n    sections: dict\n        Dictionary with sections and their spans\n    \"\"\"\n\n    spans = []\n    for match in re.finditer(r\"\\[SECTION\\]\", data):\n        spans.append(match.span())\n\n    if spans == []:\n        logging.info(\"Could not find the relevant tag\")\n        return sections\n\n    for (start, end) in spans:\n        assert end == start + 9, f\"Span is of length {end - start}\"\n\n    for section, sec_spans in sections.items():\n        n_spans = []\n        for span in sec_spans:\n            n_span = get_closest(span, spans)\n            n_spans.append(n_span)\n        sections[section] = n_spans\n\n    return sections\n</code></pre>"},{"location":"reference/preprocess/clean/","title":"clean","text":"<p>Remove extra whitespaces, non-utf-8 characters and carry out substitutions.</p>"},{"location":"reference/preprocess/clean/#src.preprocess.clean.clean","title":"<code>clean(text, punct=None, **kwargs)</code>","text":"<p>Clean unwanted characters, extra whitespaces, unnecessary punctuations and sentence splits.</p>"},{"location":"reference/preprocess/clean/#src.preprocess.clean.clean--parameters","title":"Parameters","text":"str <p>Text to process.</p> str <p>Punctuation string to use. (Mainly for second run through after masking)</p>"},{"location":"reference/preprocess/clean/#src.preprocess.clean.clean--returns","title":"Returns","text":"str <p>Processed text.</p> Source code in <code>src/preprocess/clean.py</code> <pre><code>def clean(text: str, punct: str = None, **kwargs) -&gt; str:\n\"\"\"Clean unwanted characters, extra whitespaces, unnecessary punctuations\n    and sentence splits.\n\n    Parameters\n    ----------\n    text : str\n        Text to process.\n    punct : str\n        Punctuation string to use. (Mainly for second run through after\n        masking)\n\n    Returns\n    -------\n    text : str\n        Processed text.\n    \"\"\"\n    # Remove non-utf-8 characters\n    text = bytes(text, 'utf-8').decode('utf-8', 'ignore')\n\n    # Remove links\n    text = regexes[\"links\"].sub('', text)\n\n    # Remove strange characters and non fullstop punctuations\n    text = regexes[\"nonwords\"].sub('', text)\n\n    # Remove extra whitespaces, hyphens and multiple dots\n    text = regexes[\"extra_spaces\"].sub(' ', text)\n    text = regexes[\"dots\"].sub('.', text)\n\n    # Removing all punctuations except those appearing for sections\n    text = regexes[\"section\"].sub(r'\\1 \\2', text)\n    text = regexes[\"extra_spaces\"].sub(' ', text)\n    text = regexes[\"page\"].sub('', text)\n    text = text.strip()\n\n    # Subsituting citation variations for special sequences\n    for k, r in special_case_regexes.items():\n        text = r.sub(k, text)\n\n    # Replacing common abbreviations of acts\n    text = text.replace(\"Constitution of India\", \"Constitution\")\n\n    for k, r in acts_regexes.items():\n        text = r.sub(k + \" \", text)\n        text = regexes[\"extra_spaces\"].sub(' ', text)\n\n    return text\n</code></pre>"},{"location":"reference/preprocess/clean/#src.preprocess.clean.parallelize","title":"<code>parallelize(**kwargs)</code>","text":"<p>Parallelization of cleaning documents</p> Source code in <code>src/preprocess/clean.py</code> <pre><code>def parallelize(**kwargs):\n\"\"\"Parallelization of cleaning documents\"\"\"\n\n    set_logger(os.path.join(kwargs[\"log_path\"], \"clean\"))\n    text = get_text(os.path.join(kwargs[\"input_path\"], kwargs[\"fl\"]))\n    text = clean(text)\n\n    flname = os.path.splitext(kwargs[\"fl\"])[0]\n    logging.info(\"Removed extra whitespaces and non-utf-8 characters from \"\n                 f\"{flname}\")\n\n    save_format(kwargs[\"output_path\"], flname, text)\n</code></pre>"},{"location":"reference/preprocess/combine/","title":"combine","text":"<p>Combine rhetorical roles into per-sentence information</p>"},{"location":"reference/preprocess/extract_statutes/","title":"extract_statutes","text":"<p>Extract statutes from documents.</p>"},{"location":"reference/preprocess/extract_statutes/#src.preprocess.extract_statutes.check_exists","title":"<code>check_exists(actsec, statutes)</code>","text":"<p>Return valid cited statutes.</p>"},{"location":"reference/preprocess/extract_statutes/#src.preprocess.extract_statutes.check_exists--parameters","title":"Parameters","text":"set <p>Set of statutes cited and their spans.</p> dict <p>Dictionary of statutes to reference.</p>"},{"location":"reference/preprocess/extract_statutes/#src.preprocess.extract_statutes.check_exists--returns","title":"Returns","text":"set <p>Valid set of statutes and their spans.</p> Source code in <code>src/preprocess/extract_statutes.py</code> <pre><code>def check_exists(actsec: set, statutes: dict) -&gt; set:\n\"\"\"Return valid cited statutes.\n\n    Parameters\n    ----------\n    actsec : set\n        Set of statutes cited and their spans.\n    statutues: dict\n        Dictionary of statutes to reference.\n\n    Returns\n    -------\n    cleaned : set\n        Valid set of statutes and their spans.\n    \"\"\"\n    cleaned = set()\n    for (a, start, end) in actsec:\n        a = a.replace(r'  ', ' ')\n        if statutes.get(a, -1) != -1:\n            cleaned.add((statutes[a], start, end))\n    return cleaned\n</code></pre>"},{"location":"reference/preprocess/extract_statutes/#src.preprocess.extract_statutes.clean","title":"<code>clean(act_sec)</code>","text":"<p>Clean up given set of extracted sections to standard format.</p>"},{"location":"reference/preprocess/extract_statutes/#src.preprocess.extract_statutes.clean--parameters","title":"Parameters","text":"set <p>Set containing statutes and their spans.</p>"},{"location":"reference/preprocess/extract_statutes/#src.preprocess.extract_statutes.clean--returns","title":"Returns","text":"set <p>Set containing formatted statutes and their spans.</p> Source code in <code>src/preprocess/extract_statutes.py</code> <pre><code>def clean(act_sec: set) -&gt; set:\n\"\"\"Clean up given set of extracted sections to standard format.\n\n    Parameters\n    ----------\n    actsec : set\n        Set containing statutes and their spans.\n\n    Returns\n    -------\n    actsec : set\n        Set containing formatted statutes and their spans.\n    \"\"\"\n    actsec = set()\n\n    for (a, start, end) in act_sec:\n        # Splitting along underscore to get the act and the section number\n        a = a.strip()\n        parts = a.split(\"_\")\n\n        # Pattern 1 Removing brackets\n        num = parts[1]\n\n        # Removing bracketed information\n        if \"(\" in parts[1]:\n            pos1 = parts[1].index(\"(\")\n            num = parts[1][:pos1]\n        if \"-\" in parts[1]:\n            pos1 = parts[1].index(\"-\")\n            num = parts[1][:pos1]\n        num = re.sub(r'\\D', '', num)\n        a3 = f\"{parts[0]}_{num}\"\n\n        actsec.add((a3, start, end))\n\n    return actsec\n</code></pre>"},{"location":"reference/preprocess/extract_statutes/#src.preprocess.extract_statutes.extract_statutes","title":"<code>extract_statutes(text, statutes, per_sentence=True)</code>","text":"<p>Finds all statutes mentioned in the given text.</p>"},{"location":"reference/preprocess/extract_statutes/#src.preprocess.extract_statutes.extract_statutes--parameters","title":"Parameters","text":"str or dict <p>Text to extract statutes from.</p> bool, default : True <p>Whether to find the statutes for each sentence. (Only works when a dictionary is passed to text.)</p>"},{"location":"reference/preprocess/extract_statutes/#src.preprocess.extract_statutes.extract_statutes--returns","title":"Returns","text":"dict <p>Dictionary of cited statutes.</p> Source code in <code>src/preprocess/extract_statutes.py</code> <pre><code>def extract_statutes(text: Union[str, dict],\n                     statutes: list,\n                     per_sentence: bool = True) -&gt; dict:\n\"\"\"Finds all statutes mentioned in the given text.\n\n    Parameters\n    ----------\n    text : str or dict\n        Text to extract statutes from.\n    per_sentence : bool, default : True\n        Whether to find the statutes for each sentence. (Only works when a\n        dictionary is passed to text.)\n\n    Returns\n    -------\n    secs : dict\n        Dictionary of cited statutes.\n    \"\"\"\n\n    orig = text\n    if (type(orig) == dict):\n        text = \" \".join([item[\"text\"] for item in text.values()])\n\n    actsec = set()\n    actsec1 = set()\n\n    actsec1 = get_statutes(text, statutes)\n\n    actsec = set(frozenset().union(actsec1))\n\n    secs = {\n        k: [*map(lambda x: (x[1], x[2]), values)]\n        for k, values in groupby(\n            sorted(actsec, key=lambda x: x[0]),\n            itemgetter(0))\n    }\n\n    logging.info(f\"Found statutes: {secs}\")\n\n    if (per_sentence and type(orig) == dict):\n        secs = sentence_align(secs, orig)\n\n    return secs\n</code></pre>"},{"location":"reference/preprocess/extract_statutes/#src.preprocess.extract_statutes.get_statutes","title":"<code>get_statutes(text, seclist)</code>","text":"<p>Find all statutes cited in text.</p>"},{"location":"reference/preprocess/extract_statutes/#src.preprocess.extract_statutes.get_statutes--parameters","title":"Parameters","text":"str <p>Text to find statutes from.</p> list <p>List of acts to use for reference.</p> list <p>List of statutes to use for verification.</p> str <p>Article or section.</p>"},{"location":"reference/preprocess/extract_statutes/#src.preprocess.extract_statutes.get_statutes--returns","title":"Returns","text":"set <p>Set containing cited statutes and spans.</p> Source code in <code>src/preprocess/extract_statutes.py</code> <pre><code>def get_statutes(text: str, seclist: list) -&gt; set:\n\"\"\"Find all statutes cited in text.\n\n    Parameters\n    ----------\n    text : str\n        Text to find statutes from.\n    actlist : list\n        List of acts to use for reference.\n    seclist : list\n        List of statutes to use for verification.\n    unit : str\n        Article or section.\n\n    Returns\n    -------\n    actsec : set\n        Set containing cited statutes and spans.\n    \"\"\"\n\n    # Matching pattern for each act\n    matches = r.finditer(text)\n\n    # Going through each match\n    for match in matches:\n        if match is None:\n            break\n\n        # Span of the match (useful for masking)\n        start, end = match.start(1), match.end(5)\n        #  match_nums = match.groups()[1]\n        match_nums = match.groups()[1]\n        logging.info(f\"Found groups: {match.groups()}\")\n        act = match.groups()[-1]\n        #  logging.info(act)\n        # Splitting when multiple sections are cited\n        nums = re.split(r'/|and|\\s+|,', match_nums)\n        for num in nums:\n            if num != '':\n                act_sec.add((f\"{act}_{num}\", start, end))\n\n        # When section ranges are specified\n        ranges = re.finditer(\n            r'([0-9]+)\\s*?(?:\\-|to)\\s*?([0-9]+)',\n            match_nums,\n            flags=re.I)\n\n        for rng in ranges:\n            if rng is None:\n                break\n\n            sec_start, sec_end = rng.groups()\n            for sec_num in range(int(sec_start), int(sec_end) + 1):\n                act_sec.add((f\"{act}_{sec_num}\", start, end))\n\n    if act_sec != set():\n        cleaned = clean(act_sec)\n        print(cleaned)\n        cleaned = check_exists(cleaned, seclist)\n\n        return cleaned\n\n    return act_sec\n</code></pre>"},{"location":"reference/preprocess/extract_statutes/#src.preprocess.extract_statutes.parallelize","title":"<code>parallelize(**kwargs)</code>","text":"<p>Parallelization of statute extraction</p> Source code in <code>src/preprocess/extract_statutes.py</code> <pre><code>def parallelize(**kwargs):\n\"\"\"Parallelization of statute extraction\"\"\"\n    set_logger(os.path.join(kwargs[\"log_path\"], \"extract_statutes\"))\n    flname = os.path.splitext(kwargs[\"fl\"])[0]\n    #  with open(os.path.join(kwargs[\"input_path\"], kwargs[\"fl\"]), 'r') as f:\n        #  text = json.load(f)\n    with open(os.path.join(kwargs[\"input_path\"], kwargs[\"fl\"]), 'r') as f:\n        text = f.read()\n\n    text = extract_statutes(text, statutes)\n    logging.info(f\"Extracted statutes for {flname}\")\n    save_format(kwargs[\"output_path\"], flname, text)\n</code></pre>"},{"location":"reference/preprocess/extract_statutes/#src.preprocess.extract_statutes.sentence_align","title":"<code>sentence_align(sentence_dict, orig)</code>","text":"<p>Align citations to sentences.</p>"},{"location":"reference/preprocess/extract_statutes/#src.preprocess.extract_statutes.sentence_align--parameters","title":"Parameters","text":"dict <p>Dictionary of statute citations.</p> dict <p>Dictionary of sentences.</p>"},{"location":"reference/preprocess/extract_statutes/#src.preprocess.extract_statutes.sentence_align--returns","title":"Returns","text":"dict <p>Dictionary with sections given for each sentence.</p> Source code in <code>src/preprocess/extract_statutes.py</code> <pre><code>def sentence_align(sentence_dict: dict, orig: dict) -&gt; dict:\n\"\"\"Align citations to sentences.\n\n    Parameters\n    ----------\n    sentence_dict : dict\n        Dictionary of statute citations.\n    orig : dict\n        Dictionary of sentences.\n\n    Returns\n    -------\n    orig : dict\n        Dictionary with sections given for each sentence.\n    \"\"\"\n\n    for idx, items in orig.items():\n        start, end = items[\"span\"]\n        sections = defaultdict(list)\n        for cite, spans in sentence_dict.items():\n            for c_start, c_end in spans:\n                if(c_start &gt;= start and c_end &lt;= end):\n\n                    sections[cite].append(\n                        (c_start - start, c_end - start))\n        orig[idx][\"sections\"] = dict(sections)\n\n    return orig\n</code></pre>"},{"location":"reference/preprocess/get_roles_sentences/","title":"get_roles_sentences","text":"<p>Get sentences of particular rhetorical roles</p>"},{"location":"reference/preprocess/get_sentences/","title":"get_sentences","text":"<p>Extract sentences from sentence-separated json files</p>"},{"location":"reference/preprocess/get_sentences/#src.preprocess.get_sentences.parallelize","title":"<code>parallelize(**kwargs)</code>","text":"<p>Parallelization of sentence extraction</p> Source code in <code>src/preprocess/get_sentences.py</code> <pre><code>def parallelize(**kwargs):\n\"\"\"Parallelization of sentence extraction\"\"\"\n    set_logger(os.path.join(kwargs[\"log_path\"], \"get_sentences\"))\n    logging.info(\"Inputs:\")\n    for name, value in kwargs.items():\n        logging.info(f\"{name}: {value}\")\n\n    with open(os.path.join(kwargs[\"input_path\"], kwargs[\"fl\"]), 'r') as f:\n        dct = json.load(f)\n\n    flname = os.path.splitext(kwargs[\"fl\"])[0]\n    logging.info(f\"Getting sentences of {flname}\")\n    with open(os.path.join(kwargs[\"output_path\"], f\"{flname}.txt\"), 'w') as f:\n        for idx, data in dct.items():\n            print(data[\"text\"], file=f, end=\"\\n\")\n</code></pre>"},{"location":"reference/preprocess/mask_advs/","title":"mask_advs","text":"<p>Mask advocate information in text</p>"},{"location":"reference/preprocess/mask_ent/","title":"mask_ent","text":"<p>Mask various patterns for given data.</p>"},{"location":"reference/preprocess/mask_ent/#src.preprocess.mask_ent.mask","title":"<code>mask(text)</code>","text":"<p>Mask given patterns by given mask strings.</p>"},{"location":"reference/preprocess/mask_ent/#src.preprocess.mask_ent.mask--parameters","title":"Parameters","text":"str <p>Text to process.</p>"},{"location":"reference/preprocess/mask_ent/#src.preprocess.mask_ent.mask--returns","title":"Returns","text":"str <p>Processed text.</p> Source code in <code>src/preprocess/mask_ent.py</code> <pre><code>def mask(text: str) -&gt; str:\n\"\"\" Mask given patterns by given mask strings.\n\n    Parameters\n    ----------\n    text : str\n        Text to process.\n    Returns\n    -------\n    text : str\n        Processed text.\n    \"\"\"\n\n    for k, r in patterns.items():\n        k = '' if k == '[PAGE]' else k\n        text = r.sub(k, text)\n\n    return text\n</code></pre>"},{"location":"reference/preprocess/mask_ent/#src.preprocess.mask_ent.mask_targets","title":"<code>mask_targets(text, targets)</code>","text":"<p>Mask names of targets in text (if any left)</p> Source code in <code>src/preprocess/mask_ent.py</code> <pre><code>def mask_targets(text: str, targets: list) -&gt; str:\n\"\"\"Mask names of targets in text (if any left)\"\"\"\n    if targets == []:\n        return text\n    target_regex = re.compile(\"|\".join([\"\\s+\\.?\".join(\n                                re.findall(r\"[A-Z][^A-Z]*\", target))\n                                        for target in targets]),\n                              flags=re.I)\n    hits = target_regex.findall(text)\n    logging.info(f\"{len(hits)} matches found for targets after entity \"\n                 \"masking. Additionally masking them.\")\n    text = target_regex.sub(\"[PERSON]\", text)\n    return text\n</code></pre>"},{"location":"reference/preprocess/mask_ent/#src.preprocess.mask_ent.ner_mask","title":"<code>ner_mask(text, nlp)</code>","text":"<p>Mask names of persons and locations.</p>"},{"location":"reference/preprocess/mask_ent/#src.preprocess.mask_ent.ner_mask--parameters","title":"Parameters","text":"str <p>Text to process.</p> spacy Object <p>Spacy model to use to get ner tags.</p>"},{"location":"reference/preprocess/mask_ent/#src.preprocess.mask_ent.ner_mask--returns","title":"Returns","text":"str <p>Processed text.</p> Source code in <code>src/preprocess/mask_ent.py</code> <pre><code>def ner_mask(text, nlp) -&gt; str:\n\"\"\" Mask names of persons and locations.\n\n    Parameters\n    ----------\n    text : str\n        Text to process.\n    nlp : spacy Object\n        Spacy model to use to get ner tags.\n\n    Returns\n    -------\n    new_text : str\n        Processed text.\n    \"\"\"\n\n    new_text = \"\"\n\n    doc = nlp(text)\n    prev_token = \"\"\n    num = 0\n    for token in doc:\n\n        append = token.text\n        if \"SECTION]\" in append:\n            new_text = new_text + append\n            continue\n\n        if token.ent_type_ != \"\":\n            append = f\"[{token.ent_type_}]\"\n            # Skip consecutive tokens of the same entity type\n            if prev_token == append:\n                continue\n            prev_token = append\n            num += 1\n\n        if append in punctuation:\n            if append == \"[\":\n                new_text = new_text + \" \" + append\n            else:\n                new_text = new_text + append\n        else:\n            if len(new_text) &gt; 0:\n                if new_text[-1] == \"[\":\n                    new_text = new_text + append\n                else:\n                    new_text = new_text + \" \" + append\n            else:\n                new_text = new_text + append\n    logging.info(f\"{num} entities were found and masked\")\n    return new_text\n</code></pre>"},{"location":"reference/preprocess/mask_ent/#src.preprocess.mask_ent.parallelize_mask","title":"<code>parallelize_mask(**kwargs)</code>","text":"<p>Parallelization of masking documents</p> Source code in <code>src/preprocess/mask_ent.py</code> <pre><code>def parallelize_mask(**kwargs):\n\"\"\"Parallelization of masking documents\"\"\"\n    flname = os.path.splitext(kwargs[\"fl\"])[0]\n\n    #  text = get_text(os.path.join(kwargs[\"input_path\"], kwargs[\"fl\"]))\n    with open(os.path.join(kwargs[\"input_path\"], kwargs[\"fl\"]), 'r') as f:\n        text = f.read()\n    text = ner_mask(text, kwargs[\"nlp\"])\n    text = mask_targets(text, kwargs[\"targets\"])\n\n    logging.info(f\"Masked data from {flname}\")\n    with open(os.path.join(kwargs[\"output_path\"], f\"{flname}.txt\"), 'w') as f:\n        f.write(text)\n</code></pre>"},{"location":"reference/preprocess/mask_statutes/","title":"mask_statutes","text":"<p>Mask sections in cases</p>"},{"location":"reference/preprocess/mask_statutes/#src.preprocess.mask_statutes.get_closest","title":"<code>get_closest(tuple_a, tuple_list)</code>","text":"<p>Return closest tuple based on first coordinate criteria</p> Source code in <code>src/preprocess/mask_statutes.py</code> <pre><code>def get_closest(tuple_a: tuple, tuple_list: list) -&gt; tuple:\n\"\"\"Return closest tuple based on first coordinate criteria\"\"\"\n    least = 0\n    dist = tuple_a[0] - tuple_list[0][0]\n    for i in range(len(tuple_list)):\n        if not tuple_list[i][0] &lt;= tuple_a[0]:\n            continue\n        n_dist = tuple_a[0] - tuple_list[i][0]\n        if n_dist &lt;= dist:\n            dist = n_dist\n            least = i\n    return tuple_list[least]\n</code></pre>"},{"location":"reference/preprocess/mask_statutes/#src.preprocess.mask_statutes.get_new_spans","title":"<code>get_new_spans(data, sections)</code>","text":"<p>Realign spans of sections after Masking</p>"},{"location":"reference/preprocess/mask_statutes/#src.preprocess.mask_statutes.get_new_spans--parameters","title":"Parameters","text":"str <p>Text information</p> dict <p>Dictionary with sections and their spans</p> Source code in <code>src/preprocess/mask_statutes.py</code> <pre><code>def get_new_spans(data: str, sections: dict) -&gt; dict:\n\"\"\"Realign spans of sections after Masking\n\n    Parameters\n    ----------\n    data: str\n        Text information\n    sections: dict\n        Dictionary with sections and their spans\n    \"\"\"\n\n    spans = []\n    for match in re.finditer(r\"\\[SECTION\\]\", data):\n        spans.append(match.span())\n\n    for (start, end) in spans:\n        assert end == start + 9, f\"Span is of length {end - start}\"\n\n    for section, sec_spans in sections.items():\n        n_spans = []\n        for span in sec_spans:\n            n_span = get_closest(span, spans)\n            n_spans.append(n_span)\n        sections[section] = n_spans\n\n    return sections\n</code></pre>"},{"location":"reference/preprocess/mask_statutes/#src.preprocess.mask_statutes.mask_statutes","title":"<code>mask_statutes(data, sections)</code>","text":"<p>Mask given sections from sentences and remove certain elements</p>"},{"location":"reference/preprocess/mask_statutes/#src.preprocess.mask_statutes.mask_statutes--parameters","title":"Parameters","text":"str <p>Text</p> dict <p>Dictionary of all sections cited in document along with their spans</p> Source code in <code>src/preprocess/mask_statutes.py</code> <pre><code>def mask_statutes(data: str, sections: dict) -&gt; Union[str, dict]:\n\"\"\"Mask given sections from sentences and remove certain elements\n\n    Parameters\n    ----------\n    data: str\n        Text\n    sections: dict\n        Dictionary of all sections cited in document along with their spans\n    \"\"\"\n    data_copy = deepcopy(data)\n    if sections:\n\n        alt_case_section_regex = re.compile(\n                \"|\".join([r\"Section\\s+{}\\s+of\\s+the\\s+(Code|Act)\".format(\n                    sec.split(\"_\")[-1])\n                    for sec in sections]))\n        replace_texts = []\n        for sec, spans in sections.items():\n            replace_texts.extend([data_copy[start:end]\n                                  for (start, end) in spans])\n        replace_texts = [rep.replace(\"(\", r\"\\(\").replace(\")\", r\"\\)\")\n                         for rep in replace_texts]\n\n        data_copy = re.sub(\"|\".join(replace_texts), \"[SECTION]\", data_copy)\n        data_copy = alt_case_section_regex.sub(\"[SECTION_UNK]\", data_copy)\n\n    alt_case_section_regex_2 = re.compile(r\"Sections?\\s+(?:[0-9]+[A-Z]*)\")\n    data_copy = alt_case_section_regex_2.sub(\"[SECTION_UNK]\", data_copy)\n    n_spans = get_new_spans(data_copy, sections)\n\n    return data_copy, n_spans\n</code></pre>"},{"location":"reference/preprocess/process/","title":"process","text":"<p>Run all pre-processing scripts in a pipeline.</p>"},{"location":"reference/preprocess/segment/","title":"segment","text":"<p>Segments documents into sentences.</p>"},{"location":"reference/preprocess/segment/#src.preprocess.segment.custom_sentencizer","title":"<code>custom_sentencizer(doc)</code>","text":"<p>Custom sentencizer for DHC corpus.</p>"},{"location":"reference/preprocess/segment/#src.preprocess.segment.custom_sentencizer--parameters","title":"Parameters","text":"str <p>Text to process.</p>"},{"location":"reference/preprocess/segment/#src.preprocess.segment.custom_sentencizer--returns","title":"Returns","text":"spacy.Doc <p>spacy document with sentence boundaries.</p>"},{"location":"reference/preprocess/segment/#src.preprocess.segment.custom_sentencizer--notes","title":"Notes","text":"Source code in <code>src/preprocess/segment.py</code> <pre><code>@Language.component(\"custom_sentencizer\")\ndef custom_sentencizer(doc: str) -&gt; object:\n\"\"\" Custom sentencizer for DHC corpus.\n\n    Parameters\n    ----------\n    doc : str\n        Text to process.\n\n    Returns\n    -------\n    doc : spacy.Doc\n        spacy document with sentence boundaries.\n\n    Notes\n    -----\n\n    \"\"\"\n    # Exception tokens\n    exceptions = [\"mr.\", \"ms.\", \"mrs.\", \"adv.\", \"advs.\", \"sr.\",\n                  \"dr.\", \"m.\", \"crl.\", \"a.\", \"advocate.\", \"advocates.\",\n                  \"w.\", \"p.\", \"fir.\", \"ltd.\", \"[CARDINAL].\"]\n\n    # The last token cannot start a sentence\n    for i, token in enumerate(doc[:-2]):\n        #  if token.text[0] == \".\" or token.text[-1] == \".\":\n\n        if \"CARDINAL\" in token.text:\n            if doc[i+1].text == \"]\" and doc[i+2].text == \".\":\n                doc[i+1].is_sent_start = False\n                doc[i+2].is_sent_start = False\n                doc[i+2].is_sent_start = False\n            continue\n\n        if token.text[-1] == \".\" or token.text[-1] == \":\":\n\n            if doc[i-1].text == \"]\" and doc[i-2].text == \"CARDINAL\":\n                continue\n\n            doc[i+1].is_sent_start = True\n\n            if (not doc[i+1].text[0].isupper() or\n                    doc[i+1].text[-1] == '.'):\n                doc[i+1].is_sent_start = False\n\n            if (token.text.lower() in exceptions):\n                doc[i+1].is_sent_start = False\n\n            if (token.text == '.'):\n                doc[i+1].is_sent_start = True\n\n            if (doc[i].is_sent_start is True):\n                doc[i+1].is_sent_start = False\n\n    return doc\n</code></pre>"},{"location":"reference/preprocess/segment/#src.preprocess.segment.fix_sentence_boundaries","title":"<code>fix_sentence_boundaries(sentence_dict)</code>","text":"<p>Fix sentence boundaries to account for extra spaces ignored by spacy.</p>"},{"location":"reference/preprocess/segment/#src.preprocess.segment.fix_sentence_boundaries--parameters","title":"Parameters","text":"dict <p>Dictionary containing sentence text and spans.</p>"},{"location":"reference/preprocess/segment/#src.preprocess.segment.fix_sentence_boundaries--returns","title":"Returns","text":"dict <p>Dictionary containing sentence texts and rectified spans.</p> Source code in <code>src/preprocess/segment.py</code> <pre><code>def fix_sentence_boundaries(sentence_dict: dict) -&gt; dict:\n\"\"\"Fix sentence boundaries to account for extra spaces ignored by spacy.\n\n    Parameters\n    ----------\n    sentence_dict: dict\n        Dictionary containing sentence text and spans.\n\n\n    Returns\n    -------\n    sent_dict: dict\n        Dictionary containing sentence texts and rectified spans.\n    \"\"\"\n    shift = 0\n    sent_dict = defaultdict(lambda: dict())\n    text = \" \".join([items[\"text\"] for items in sentence_dict.values()])\n\n    for idx, items in sentence_dict.items():\n        start, end = items[\"span\"]\n        for char in text[start + shift: end + shift]:\n            if char not in [' ', '.']:\n                break\n            shift += 1\n\n        sent_dict[idx] = {\n            \"span\": tuple((start + shift, end + shift)),\n            \"text\": items[\"text\"]\n        }\n    return dict(sent_dict)\n</code></pre>"},{"location":"reference/preprocess/segment/#src.preprocess.segment.segment","title":"<code>segment(text, nlp)</code>","text":"<p>Segment sentences by boundary.</p>"},{"location":"reference/preprocess/segment/#src.preprocess.segment.segment--parameters","title":"Parameters","text":"str <p>Text to process.</p> spacy object(?) <p>Spacy object to use for segmentation.</p>"},{"location":"reference/preprocess/segment/#src.preprocess.segment.segment--returns","title":"Returns","text":"dict <p>Dictionary containing each sentence and their span.</p> Source code in <code>src/preprocess/segment.py</code> <pre><code>def segment(text: str, nlp) -&gt; dict:\n\"\"\"Segment sentences by boundary.\n\n    Parameters\n    ----------\n    text : str\n        Text to process.\n    nlp : spacy object(?)\n        Spacy object to use for segmentation.\n\n    Returns\n    -------\n    sent_dict : dict\n        Dictionary containing each sentence and their span.\n    \"\"\"\n    doc = nlp(text)\n\n    sent_dict = defaultdict(lambda: dict())\n    try:\n        for i, sent in enumerate(doc.sents):\n            start = sent.start_char\n            end = sent.end_char\n            sent_dict[i] = {\n                \"span\": tuple((start, end)),\n                \"text\": sent.text,\n            }\n    except ValueError as e:\n        logging.info(str(repr(e)))\n        logging.info(\"Could not detect sentence boundaries. Skipping\")\n        return {}\n\n    sent_dict = fix_sentence_boundaries(sent_dict)\n    return sent_dict\n</code></pre>"},{"location":"reference/preprocess/utils/","title":"utils","text":"<p>Utilities for pre-processing.</p>"},{"location":"reference/preprocess/utils/#src.preprocess.utils.DotDict","title":"<code>DotDict</code>","text":"<p>         Bases: <code>dict</code></p> <p>dot.notation access to dictionary attributes</p> Source code in <code>src/preprocess/utils.py</code> <pre><code>class DotDict(dict):\n\"\"\"dot.notation access to dictionary attributes\"\"\"\n    def __getattr__(*args):\n        val = dict.get(*args)\n        return DotDict(val) if type(val) is dict else val\n\n    __setattr__ = dict.__setitem__\n    __delattr__ = dict.__delitem__\n</code></pre>"},{"location":"reference/preprocess/utils/#src.preprocess.utils.get_text","title":"<code>get_text(path, log_path=None)</code>","text":"<p>Load html data and return text of the of <p> divs of the data.</p> Source code in <code>src/preprocess/utils.py</code> <pre><code>def get_text(path: str, log_path: str = None) -&gt; str:\n\"\"\"Load html data and return text of the of &lt;p&gt; divs of the data.\"\"\"\n\n    if log_path is not None:\n        set_logger(log_path)\n    logging.info(f\"Reading data from {path}\")\n    with open(path, 'r') as f:\n        raw = f.read()\n    soup = bs(raw)\n    parts = soup.findAll('div',\n                         class_=[\"docsource_main\", \"doc_title\", \"doc_author\"])\n    for part in parts:\n        part.decompose()\n    parts = soup.findAll('pre')\n    for part in parts:\n        part.decompose()\n    text = soup.text\n    return text\n</code></pre>"},{"location":"reference/preprocess/utils/#src.preprocess.utils.order","title":"<code>order(dict_obj)</code>","text":"<p>Order dictionary in decreasing order of values</p>"},{"location":"reference/preprocess/utils/#src.preprocess.utils.order--parameters","title":"Parameters","text":"dict <p>Dictionary to be sorted.</p>"},{"location":"reference/preprocess/utils/#src.preprocess.utils.order--returns","title":"Returns","text":"<p>dict</p> Source code in <code>src/preprocess/utils.py</code> <pre><code>def order(dict_obj: dict) -&gt; dict:\n\"\"\"Order dictionary in decreasing order of values\n\n    Parameters\n    ----------\n    dict_obj : dict\n        Dictionary to be sorted.\n\n    Returns\n    -------\n    dict\n\n    \"\"\"\n\n    ordered_dict = {\n            k: v for k, v in sorted(dict_obj.items(),\n                                    key=lambda x: x[1],\n                                    reverse=True)}\n    return ordered_dict\n</code></pre>"},{"location":"reference/preprocess/utils/#src.preprocess.utils.save_format","title":"<code>save_format(path, flname, data)</code>","text":"<p>Saves data to the given path depending on the data type.</p> Source code in <code>src/preprocess/utils.py</code> <pre><code>def save_format(path, flname, data):\n\"\"\"Saves data to the given path depending on the data type.\"\"\"\n\n    if (type(data) == str):\n        with open(os.path.join(path, f\"{flname}.txt\"), 'w') as f:\n            f.write(data)\n\n    if (type(data) == dict):\n        with open(os.path.join(path, f\"{flname}.json\"), 'w') as f:\n            json.dump(data, f, indent=4)\n</code></pre>"},{"location":"reference/preprocess/utils/#src.preprocess.utils.set_logger","title":"<code>set_logger(log_path)</code>","text":"<p>Set logger to log information to the terminal and the specified path.</p>"},{"location":"reference/preprocess/utils/#src.preprocess.utils.set_logger--parameters","title":"Parameters","text":"str <p>Path to log run-stats to.</p> Source code in <code>src/preprocess/utils.py</code> <pre><code>def set_logger(log_path):\n\"\"\"Set logger to log information to the terminal and the specified path.\n\n    Parameters\n    ----------\n    log_path : str\n        Path to log run-stats to.\n    \"\"\"\n\n    timestamp = strftime(\"%Y-%m-%d-%H-%M-%S\")\n    log_path = log_path + \"_\" + timestamp + \".log\"\n\n    logger = logging.getLogger()\n    logger.setLevel(logging.INFO)\n\n    if not logger.handlers:\n        # FileHandler to log to a file\n        file_handler = logging.FileHandler(log_path)\n        file_handler.setFormatter(logging.Formatter(\n            \"%(asctime)s : [%(levelname)s] %(message)s\",\n            \"%Y-%m-%d %H:%M:%S\"))\n        logger.addHandler(file_handler)\n\n        # StreamHandler to log to terminal\n        stream_handler = logging.StreamHandler()\n        stream_handler.setFormatter(logging.Formatter(\n            \"%(asctime)s : [%(levelname)s] %(message)s\",\n            \"%Y-%m-%d %H:%M:%S\"))\n        logger.addHandler(stream_handler)\n</code></pre>"},{"location":"reference/selection/select_advocates/","title":"select_advocates","text":"<p>Select advocates from a given list of advocates and their cases based on the number of cases.</p>"},{"location":"reference/selection/select_cases_from_groups/","title":"select_cases_from_groups","text":"<p>Select cases based on provided selection conditions.</p>"},{"location":"reference/selection/select_cases_from_groups/#src.selection.select_cases_from_groups.clean_min_acts","title":"<code>clean_min_acts(select_case_info, prune_acts, act_areas)</code>","text":"<p>Prune given set of acts from all cases, removing cases with no other act information</p>"},{"location":"reference/selection/select_cases_from_groups/#src.selection.select_cases_from_groups.clean_min_acts--parameters","title":"Parameters","text":"dict <p>Dictionary with act, chapter and section information of cases</p> list <p>List of acts to prune</p> dict <p>Mapping of acts to areas</p>"},{"location":"reference/selection/select_cases_from_groups/#src.selection.select_cases_from_groups.clean_min_acts--returns","title":"Returns","text":"dict <p>Dictionary with act, chapter and section information of cases after removing acts</p> Source code in <code>src/selection/select_cases_from_groups.py</code> <pre><code>def clean_min_acts(select_case_info: dict, prune_acts: list,\n                   act_areas: dict) -&gt; dict:\n\"\"\"\n    Prune given set of acts from all cases, removing cases with no other act\n    information\n\n    Parameters\n    ----------\n    select_case_info: dict\n        Dictionary with act, chapter and section information of cases\n    prune_acts: list\n        List of acts to prune\n    act_areas: dict\n        Mapping of acts to areas\n\n    Returns\n    -------\n    case_info: dict\n        Dictionary with act, chapter and section information of cases after\n        removing acts\n    \"\"\"\n    case_info = deepcopy(select_case_info)\n\n    for case, info in select_case_info.items():\n        acts = set(info[\"acts\"]) - set(prune_acts)\n        if not acts:\n            del case_info[case]\n            continue\n\n        areas = [act_areas.get(act, \"\") for act in acts]\n\n        sections = [section for section in info[\"sections\"]\n                    if section.split(\"_\")[0] not in prune_acts]\n        chapters = [chapter for chapter in info[\"chapters\"]\n                    if chapter.split(\"_\")[0] not in prune_acts]\n\n        case_info[case] = {\"areas\": order(\n                               {area: info[\"areas\"][area]\n                                for area in areas}),\n                           \"acts\": order(\n                               {act: info[\"acts\"][act]\n                                for act in acts}),\n                           \"chapters\": order(\n                               {chapter: info[\"chapters\"][chapter]\n                                for chapter in chapters}),\n                           \"sections\": order(\n                               {section: info[\"sections\"][section]\n                                for section in sections})\n                           }\n\n    return case_info\n</code></pre>"},{"location":"reference/selection/select_cases_from_groups/#src.selection.select_cases_from_groups.clean_min_areas","title":"<code>clean_min_areas(select_case_info, prune_areas, act_areas)</code>","text":"<p>Prune given set of areas from all cases, removing cases with no other area information</p>"},{"location":"reference/selection/select_cases_from_groups/#src.selection.select_cases_from_groups.clean_min_areas--parameters","title":"Parameters","text":"dict <p>Dictionary with act, chapter and section information of cases</p> list <p>List of areas to prune</p> dict <p>Mapping of acts to areas</p>"},{"location":"reference/selection/select_cases_from_groups/#src.selection.select_cases_from_groups.clean_min_areas--returns","title":"Returns","text":"dict <p>Dictionary with act, chapter and section information of cases after removing acts</p> Source code in <code>src/selection/select_cases_from_groups.py</code> <pre><code>def clean_min_areas(select_case_info: dict, prune_areas: list,\n                    act_areas: dict) -&gt; dict:\n\"\"\"\n    Prune given set of areas from all cases, removing cases with no other area\n    information\n\n    Parameters\n    ----------\n    select_case_info: dict\n        Dictionary with act, chapter and section information of cases\n    prune_areas: list\n        List of areas to prune\n    act_areas: dict\n        Mapping of acts to areas\n\n    Returns\n    -------\n    case_info: dict\n        Dictionary with act, chapter and section information of cases after\n        removing acts\n    \"\"\"\n    case_info = deepcopy(select_case_info)\n\n    for case, info in select_case_info.items():\n        areas = set(info[\"areas\"]) - set(prune_areas)\n        if not areas:\n            del case_info[case]\n            continue\n\n        acts = [act for act in info[\"acts\"]\n                if act_areas[act.split(\"_\")[0]] not in prune_areas]\n        sections = [section for section in info[\"sections\"]\n                    if act_areas[section.split(\"_\")[0]] not in prune_areas]\n        chapters = [chapter for chapter in info[\"chapters\"]\n                    if act_areas[chapter.split(\"_\")[0]] not in prune_areas]\n\n        case_info[case] = {\"areas\": order(\n                               {area: info[\"areas\"][area]\n                                for area in areas}),\n                           \"acts\": order(\n                               {act: info[\"acts\"][act]\n                                for act in acts}),\n                           \"chapters\": order(\n                               {chapter: info[\"chapters\"][chapter]\n                                for chapter in chapters}),\n                           \"sections\": order(\n                               {section: info[\"sections\"][section]\n                                for section in sections})\n                           }\n\n    return case_info\n</code></pre>"},{"location":"reference/selection/select_cases_from_groups/#src.selection.select_cases_from_groups.clean_min_chapters","title":"<code>clean_min_chapters(select_case_info, prune_chapters, section_chapters, act_areas)</code>","text":"<p>Prune given set of chapters from all cases, along with relevant sections and acts, removing cases with no other chapter information</p>"},{"location":"reference/selection/select_cases_from_groups/#src.selection.select_cases_from_groups.clean_min_chapters--parameters","title":"Parameters","text":"dict <p>Dictionary with act, chapter and section information of cases</p> list <p>List of chapters to prune</p> dict <p>Dictionary with the chapter information of acts</p>"},{"location":"reference/selection/select_cases_from_groups/#src.selection.select_cases_from_groups.clean_min_chapters--returns","title":"Returns","text":"dict <p>Dictionary with act, chapter and section information of cases after removing chapters</p> Source code in <code>src/selection/select_cases_from_groups.py</code> <pre><code>def clean_min_chapters(select_case_info: dict, prune_chapters: list,\n                       section_chapters: dict, act_areas: dict) -&gt; dict:\n\"\"\"\n    Prune given set of chapters from all cases, along with relevant sections\n    and acts, removing cases with no other chapter information\n\n    Parameters\n    ----------\n    select_case_info: dict\n        Dictionary with act, chapter and section information of cases\n    prune_chapters: list\n        List of chapters to prune\n    section_chapters: dict\n        Dictionary with the chapter information of acts\n\n    Returns\n    -------\n    case_info: dict\n        Dictionary with act, chapter and section information of cases after\n        removing chapters\n    \"\"\"\n    case_info = deepcopy(select_case_info)\n\n    for case, info in select_case_info.items():\n        chapters = set(info[\"chapters\"]) - set(prune_chapters)\n        if not chapters:\n            del case_info[case]\n            continue\n\n        sections = [section for section in info[\"sections\"]\n                    if section_chapters[section] not in prune_chapters]\n\n        case_info[case] = {\"areas\": order(\n                            Counter([act_areas.get(section.split(\"_\")[0], \"\")[0]\n                                     for section in sections])),\n\n                           \"acts\": order(\n                            Counter([section.split(\"_\")[0]\n                                     for section in sections])),\n                           \"chapters\": order(\n                               {chapter: info[\"chapters\"][chapter]\n                                for chapter in chapters}),\n                           \"sections\": order(\n                               {section: info[\"sections\"][section]\n                                for section in sections})\n                           }\n\n    return case_info\n</code></pre>"},{"location":"reference/selection/select_cases_from_groups/#src.selection.select_cases_from_groups.clean_min_sections","title":"<code>clean_min_sections(select_case_info, prune_sections, section_chapters, act_areas)</code>","text":"<p>Prune given set of sections from all cases, along with relevant chapters and acts, removing cases with no other section information</p>"},{"location":"reference/selection/select_cases_from_groups/#src.selection.select_cases_from_groups.clean_min_sections--parameters","title":"Parameters","text":"dict <p>Dictionary with act, chapter and section information of cases</p> list <p>List of sections to prune</p> dict <p>Dictionary with the chapter information of acts</p>"},{"location":"reference/selection/select_cases_from_groups/#src.selection.select_cases_from_groups.clean_min_sections--returns","title":"Returns","text":"dict <p>Dictionary with act, chapter and section information of cases after removing sections</p> Source code in <code>src/selection/select_cases_from_groups.py</code> <pre><code>def clean_min_sections(select_case_info: dict, prune_sections: list,\n                       section_chapters: dict, act_areas: dict) -&gt; dict:\n\"\"\"\n    Prune given set of sections from all cases, along with relevant chapters\n    and acts, removing cases with no other section information\n\n    Parameters\n    ----------\n    select_case_info: dict\n        Dictionary with act, chapter and section information of cases\n    prune_section: list\n        List of sections to prune\n    section_chapters: dict\n        Dictionary with the chapter information of acts\n\n    Returns\n    -------\n    case_info: dict\n        Dictionary with act, chapter and section information of cases after\n        removing sections\n    \"\"\"\n    case_info = deepcopy(select_case_info)\n\n    for case, info in select_case_info.items():\n        sections = set(info[\"sections\"]) - set(prune_sections)\n        if not sections:\n            del case_info[case]\n            continue\n\n        print(info)\n\n        print(act_areas.get(list(sections)[0].split(\"_\")[0], \"\"))\n        case_info[case] = {\"areas\": order(\n                            Counter([act_areas.get(section.split(\"_\")[0], \"\")[0]\n                                     for section in sections])),\n                           \"acts\": order(Counter([\n                                        section.split(\"_\")[0]\n                                        for section in sections])),\n                           \"chapters\": order(Counter([\n                                            section_chapters.get(section, \"\")\n                                            for section in sections])),\n                           \"sections\": order(\n                               {section: info[\"sections\"][section]\n                                for section in sections})\n                           }\n\n\n    return case_info\n</code></pre>"},{"location":"reference/selection/select_databank_cases/","title":"select_databank_cases","text":"<p>Select cases for databank from training cases</p>"},{"location":"reference/selection/utils/","title":"utils","text":"<p>Common utilities.</p>"},{"location":"reference/selection/utils/#src.selection.utils.clean_names","title":"<code>clean_names(adv_list, check=None)</code>","text":"<p>Takes a list of advocate names, a dictionary of advocates with their assigned cases and a case text and adds the case to the appropriate advocate with the right prefix for petitioner or respondent</p> Source code in <code>src/selection/utils.py</code> <pre><code>def clean_names(adv_list, check=None):\n\"\"\"Takes a list of advocate names, a dictionary of advocates with their\n    assigned cases and a case text and adds the case to the appropriate\n    advocate with the right prefix for petitioner or respondent\n    \"\"\"\n\n    salutations = ['Mr', 'Ms', 'Mrs', 'Dr', 'Mr.', 'Mrs.', 'Ms.', 'Dr.']\n    except_tokens = [\"For\", \"CORAM\", \"Hon'ble\", \"Advocate\", \"Advocates\"]\n    cleaned_advs = []\n\n    for adv in adv_list:\n        adv = re.split(r',|\\.|\\s+', adv)\n\n        adv = list(filter(None, adv))\n\n        # Using replace instead of strip due to abbreviated names with\n        adv = [token for token in adv\n               if token[0].isupper() and token not in salutations\n               and token not in except_tokens]\n\n        if(len(adv) &lt;= 1):\n            continue\n        cleaned_advs.append(\"\".join(adv))\n\n    if check is not None:\n        return list(set([adv for adv in cleaned_advs if adv not in check]))\n\n    return list(set(cleaned_advs))\n</code></pre>"},{"location":"reference/selection/utils/#src.selection.utils.order","title":"<code>order(dict_obj)</code>","text":"<p>Order dictionary in decreasing order of values</p>"},{"location":"reference/selection/utils/#src.selection.utils.order--parameters","title":"Parameters","text":"dict <p>Dictionary to be sorted.</p>"},{"location":"reference/selection/utils/#src.selection.utils.order--returns","title":"Returns","text":"<p>dict</p> Source code in <code>src/selection/utils.py</code> <pre><code>def order(dict_obj: dict) -&gt; dict:\n\"\"\"Order dictionary in decreasing order of values\n\n    Parameters\n    ----------\n    dict_obj : dict\n        Dictionary to be sorted.\n\n    Returns\n    -------\n    dict\n\n    \"\"\"\n\n    ordered_dict = {\n            k: v for k, v in sorted(dict_obj.items(),\n                                    key=lambda x: x[1],\n                                    reverse=True)}\n    return ordered_dict\n</code></pre>"},{"location":"reference/selection/utils/#src.selection.utils.set_logger","title":"<code>set_logger(log_path)</code>","text":"<p>Set logger to log information to the terminal and the specified path.</p>"},{"location":"reference/selection/utils/#src.selection.utils.set_logger--parameters","title":"Parameters","text":"str <p>Path to log run-stats to.</p> Source code in <code>src/selection/utils.py</code> <pre><code>def set_logger(log_path):\n\"\"\"Set logger to log information to the terminal and the specified path.\n\n    Parameters\n    ----------\n    log_path : str\n        Path to log run-stats to.\n    \"\"\"\n    timestamp = time.strftime(\"%Y-%m-%d-%H-%m-%S\")\n\n    log_path = log_path + \"_\" + timestamp + \".log\"\n\n    logger = logging.getLogger()\n    logger.setLevel(logging.INFO)\n\n    if not logger.handlers:\n        # FileHandler to log to a file\n        file_handler = logging.FileHandler(log_path)\n        file_handler.setFormatter(logging.Formatter(\n            \"%(asctime)s : [%(levelname)s] %(message)s\",\n            \"%Y-%m-%d %H:%M:%S\"))\n        logger.addHandler(file_handler)\n\n        # StreamHandler to log to terminal\n        stream_handler = logging.StreamHandler()\n        stream_handler.setFormatter(logging.Formatter(\n            \"%(asctime)s : [%(levelname)s] %(message)s\",\n            \"%Y-%m-%d %H:%M:%S\"))\n        logger.addHandler(stream_handler)\n</code></pre>"},{"location":"reference/selection/utils/#src.selection.utils.time_logger","title":"<code>time_logger(original_func)</code>","text":"<p>Time logging for method.</p> Source code in <code>src/selection/utils.py</code> <pre><code>def time_logger(original_func):\n\"\"\"Time logging for method.\"\"\"\n\n    @wraps(original_func)\n    def wrapper(*args, **kwargs):\n        start = time.time()\n        result = original_func(*args, **kwargs)\n        elapsed = time.time() - start\n        logging.info(\n            f\"Method {original_func.__name__} ran for {elapsed:.3f} sec(s)\")\n        return result\n    return wrapper\n</code></pre>"},{"location":"reference/selection/notebooks/check_skmultilearn/","title":"check_skmultilearn","text":""},{"location":"reference/targets/get_balanced_targets/","title":"get_balanced_targets","text":"<p>Create heterogeneous targets using label hierarchy to reduce imbalance</p>"},{"location":"reference/targets/get_balanced_targets/#src.targets.get_balanced_targets.imbalance_ratios","title":"<code>imbalance_ratios(target_cases)</code>","text":"<p>Compute imbalance ratios for given targets</p> Source code in <code>src/targets/get_balanced_targets.py</code> <pre><code>def imbalance_ratios(target_cases: dict) -&gt; Tuple[float, float, float, float]:\n\"\"\"Compute imbalance ratios for given targets\"\"\"\n    max_class = max(map(lambda x: len(x), target_cases.values()))\n    imbl = [max_class * 1./len(v) for v in target_cases.values()]\n    max_imbl = max(imbl)\n    min_imbl = min(imbl)\n    stdev_imbl = stdev(imbl)\n    mean_imbl = mean(imbl)\n    return max_imbl, min_imbl, stdev_imbl, mean_imbl\n</code></pre>"},{"location":"reference/targets/get_per_charge_win_ratios/","title":"get_per_charge_win_ratios","text":"<p>Compute per-charge win ratios of advocates. Different strategies can be used for this computation.</p>"},{"location":"reference/targets/get_per_charge_win_ratios/#src.targets.get_per_charge_win_ratios.avg_win_ratio","title":"<code>avg_win_ratio(p_cases, d_cases, scores)</code>","text":"<p>Compute average win-ratio of one advocate from a given list of cases.</p>"},{"location":"reference/targets/get_per_charge_win_ratios/#src.targets.get_per_charge_win_ratios.avg_win_ratio--parameters","title":"Parameters","text":"set <p>Set of cases where advocate was petitioner.</p> set <p>Set of cases where advocate was defendant.</p> dict <p>Dictionary with case decisions.</p>"},{"location":"reference/targets/get_per_charge_win_ratios/#src.targets.get_per_charge_win_ratios.avg_win_ratio--returns","title":"Returns","text":"float <p>Computed win_ratio.</p> Source code in <code>src/targets/get_per_charge_win_ratios.py</code> <pre><code>def avg_win_ratio(p_cases: set, d_cases: set, scores: dict) -&gt; float:\n\"\"\"Compute average win-ratio of one advocate from a given list of cases.\n\n    Parameters\n    ----------\n    p_cases: set\n        Set of cases where advocate was petitioner.\n    d_cases: set\n        Set of cases where advocate was defendant.\n    scores: dict\n        Dictionary with case decisions.\n\n    Returns\n    -------\n    ratio: float\n        Computed win_ratio.\n    \"\"\"\n    case_list = list(p_cases.union(d_cases))\n    won_p = (np.array([scores[case] for case in case_list]) *\n             np.array([case in p_cases for case in case_list]))\n    won_d = (np.array([1 - scores[case] for case in case_list]) *\n             np.array([case in d_cases for case in case_list]))\n\n    return ((sum(won_p + won_d) * 1./len(case_list))\n            if len(case_list) != 0 else 0.0)\n</code></pre>"},{"location":"reference/targets/get_silver_targets/","title":"get_silver_targets","text":"<p>Create silver-standard target information using overlap criteria of attributes of datapoints and targets</p>"},{"location":"reference/targets/get_silver_targets/#src.targets.get_silver_targets.overlap","title":"<code>overlap(data_attribute, target_attribute)</code>","text":"<p>Overlap between data attribute and target attribute</p>"},{"location":"reference/targets/get_silver_targets/#src.targets.get_silver_targets.overlap--parameters","title":"Parameters","text":"list <p>Data attribute(s)</p> list <p>Target attribute(s)</p>"},{"location":"reference/targets/get_silver_targets/#src.targets.get_silver_targets.overlap--returns","title":"Returns","text":"<p>float     Overlap value</p> Source code in <code>src/targets/get_silver_targets.py</code> <pre><code>def overlap(data_attribute: list, target_attribute: list) -&gt; float:\n\"\"\"Overlap between data attribute and target attribute\n\n    Parameters\n    ----------\n    data_attribute : list\n        Data attribute(s)\n    target_attribute : list\n        Target attribute(s)\n\n    Returns\n    -------\n    float\n        Overlap value\n    \"\"\"\n    return (\n        len(set(data_attribute).intersection(set(target_attribute)))\n        * 1.0\n        / len(set(data_attribute))\n    )\n</code></pre>"},{"location":"reference/targets/get_targets/","title":"get_targets","text":"<p>Create target information for items</p>"},{"location":"reference/targets/get_winning_advs/","title":"get_winning_advs","text":"<p>Getting winning advocates of each case based on ruling in favour of Petitioner or Defendant</p>"},{"location":"reference/targets/utils/","title":"utils","text":"<p>Utilities for pre-processing.</p>"},{"location":"reference/targets/utils/#src.targets.utils.DotDict","title":"<code>DotDict</code>","text":"<p>         Bases: <code>dict</code></p> <p>dot.notation access to dictionary attributes</p> Source code in <code>src/targets/utils.py</code> <pre><code>class DotDict(dict):\n\"\"\"dot.notation access to dictionary attributes\"\"\"\n    def __getattr__(*args):\n        val = dict.get(*args)\n        return DotDict(val) if type(val) is dict else val\n\n    __setattr__ = dict.__setitem__\n    __delattr__ = dict.__delitem__\n</code></pre>"},{"location":"reference/targets/utils/#src.targets.utils.get_text","title":"<code>get_text(path, log_path=None)</code>","text":"<p>Load html data and return text of the data.</p> Source code in <code>src/targets/utils.py</code> <pre><code>def get_text(path: str, log_path: str = None) -&gt; str:\n\"\"\"Load html data and return text of the data.\"\"\"\n\n    if log_path is not None:\n        set_logger(log_path)\n    logging.info(f\"Reading data from {path}\")\n    with open(path, 'r') as f:\n        raw = f.read()\n    soup = bs(raw, 'html.parser')\n    text = soup.get_text()\n    return text\n</code></pre>"},{"location":"reference/targets/utils/#src.targets.utils.order","title":"<code>order(dict_obj)</code>","text":"<p>Order dictionary in decreasing order of values</p>"},{"location":"reference/targets/utils/#src.targets.utils.order--parameters","title":"Parameters","text":"dict <p>Dictionary to be sorted.</p>"},{"location":"reference/targets/utils/#src.targets.utils.order--returns","title":"Returns","text":"<p>dict</p> Source code in <code>src/targets/utils.py</code> <pre><code>def order(dict_obj: dict) -&gt; dict:\n\"\"\"Order dictionary in decreasing order of values\n\n    Parameters\n    ----------\n    dict_obj : dict\n        Dictionary to be sorted.\n\n    Returns\n    -------\n    dict\n\n    \"\"\"\n\n    ordered_dict = {\n            k: v for k, v in sorted(dict_obj.items(),\n                                    key=lambda x: x[1],\n                                    reverse=True)}\n    return ordered_dict\n</code></pre>"},{"location":"reference/targets/utils/#src.targets.utils.save_format","title":"<code>save_format(path, flname, data)</code>","text":"<p>Saves data to the given path depending on the data type.</p> Source code in <code>src/targets/utils.py</code> <pre><code>def save_format(path, flname, data):\n\"\"\"Saves data to the given path depending on the data type.\"\"\"\n\n    if (type(data) == str):\n        with open(os.path.join(path, f\"{flname}.txt\"), 'w') as f:\n            f.write(data)\n\n    if (type(data) == dict):\n        with open(os.path.join(path, f\"{flname}.json\"), 'w') as f:\n            json.dump(data, f, indent=4)\n</code></pre>"},{"location":"reference/targets/utils/#src.targets.utils.set_logger","title":"<code>set_logger(log_path)</code>","text":"<p>Set logger to log information to the terminal and the specified path.</p>"},{"location":"reference/targets/utils/#src.targets.utils.set_logger--parameters","title":"Parameters","text":"str <p>Path to log run-stats to.</p> Source code in <code>src/targets/utils.py</code> <pre><code>def set_logger(log_path):\n\"\"\"Set logger to log information to the terminal and the specified path.\n\n    Parameters\n    ----------\n    log_path : str\n        Path to log run-stats to.\n    \"\"\"\n\n    timestamp = strftime(\"%Y-%m-%d-%H-%M-%S\")\n    log_path = log_path + \"_\" + timestamp + \".log\"\n\n    logger = logging.getLogger()\n    logger.setLevel(logging.INFO)\n\n    if not logger.handlers:\n        # FileHandler to log to a file\n        file_handler = logging.FileHandler(log_path)\n        file_handler.setFormatter(logging.Formatter(\n            \"%(asctime)s : [%(levelname)s] %(message)s\",\n            \"%Y-%m-%d %H:%M:%S\"))\n        logger.addHandler(file_handler)\n\n        # StreamHandler to log to terminal\n        stream_handler = logging.StreamHandler()\n        stream_handler.setFormatter(logging.Formatter(\n            \"%(asctime)s : [%(levelname)s] %(message)s\",\n            \"%Y-%m-%d %H:%M:%S\"))\n        logger.addHandler(stream_handler)\n</code></pre>"}]}